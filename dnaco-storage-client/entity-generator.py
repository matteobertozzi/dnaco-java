#!/usr/bin/env python3

from collections import namedtuple
from datetime import datetime

import string
import sys
import re
import os

def to_camel_case(snake_str):
    components = snake_str.split('_')
    return ''.join(x.title() for x in components)

def camel_to_snake(name):
  name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
  return re.sub('([a-z0-9])([A-Z])', r'\1_\2', name).lower()

class InlineEnum:
  def __init__(self, *args):
    self.name = args[0]
    self.values = [v.strip() for v in args[1].split(',')]

  def __repr__(self):
    return 'enum %s: %s' % (self.name, self.values)

class EntityField:
  def __init__(self, *args):
    self.is_key = args[0] == '@key'
    self.field_type = args[1]
    self.field_name = args[2]
    self.default_value = args[3] if args[3] else None

  def __repr__(self):
    return '%s: %s (default=%s) %s' % (self.field_name, self.field_type, self.default_value, 'KEY' if self.is_key else '')


JAVA_ENUM_TEMPLATE = """
// Autogenerated on ${build_date}
package ${entity_ns};

public enum ${entity_name} {
  ${enum_values}
}
"""

JAVA_MODEL_TEMPLATE = """
// Autogenerated on ${build_date}
package ${entity_ns};

import java.util.BitSet;

import tech.dnaco.storage.entity.StorageEntity;

${custom_import}

public class ${entity_name} implements StorageEntity {
  ${inline_enums}

  private final transient BitSet changes = new BitSet(${fields_count});

  // key members
  ${members_key}

  // field members
  ${members_field}

  // ===== ctor ========================================================
  public ${entity_name}() {
    // no-op
  }

  public ${entity_name}(final ${entity_name} other) {
    ${ctor_copy}
  }

  // ===== Setters & Getters ========================================================
  public ${entity_name} resetChanges() {
    changes.clear();
    return this;
  }

  ${getter_setter}

  // ===== Util =====================================================================
  @Override
  public String toString() {
    ${entity_string}
  }
}
"""

JAVA_GETTER_SETTER_TEMPLATE = """
  // ----- ${field_name} field -----
  public boolean is${camel_field_name}Changed() {
    return changes.get(${field_index});
  }

  public ${field_type} get${camel_field_name}() {
    return this.${field_name};
  }

  public ${entity_name} set${camel_field_name}(final ${field_type} value) {
    this.changes.set(${field_index});
    this.${field_name} = value;
    return this;
  }
"""

def replaceTemplateVars(template, templateFields):
  template = template
  for k, v in templateFields.items():
    # it's not easy to do something worse...
    template = template.replace('${%s}' % k, str(v))

  # remove trailing spaces and multiple new lines
  template = re.sub(r'[ ]+$', '', template, flags=re.M)
  template = re.sub(r'\n\n$', '\n', template, flags=re.M)
  return template

def _generateJavaCtorCopy(fields):
  copyFields = []
  for f in fields:
    camelFieldName = to_camel_case(f.field_name)
    copyFields.append('set%s(other.get%s());' % (camelFieldName, camelFieldName))
  return '\n    '.join(copyFields)

def _generateJavaModelToString(entityName, fields):
  entityData = []
  for f in fields:
    entityData.append("%s='\" + this.%s + \"'" % (f.field_name, f.field_name))
  return 'return "%s [%s]";' % (entityName, ', '.join(entityData))

def _generateJavaSettersAndGetters(entityName, fields):
  code = []
  for index, f in enumerate(fields):
    fieldName = to_camel_case(f.field_name)
    templateVars = {
      'camel_field_name': fieldName[0].upper() + fieldName[1:],
      'field_name': f.field_name,
      'field_index': index,
      'field_type': f.field_type,
      'entity_name': entityName
    }
    code.append(replaceTemplateVars(JAVA_GETTER_SETTER_TEMPLATE, templateVars))

  return '\n  '.join(code)

def _generateJavaModelMembers(fields):
  keys = []
  members = []
  for f in fields:
    code = ''
    if f.is_key:
      code += '@StorageKeyField(index = %d) ' % len(keys)

    code += 'private %s %s' % (f.field_type, f.field_name)
    if f.default_value:
      code += ' = %s' % f.default_value
    code += ';'

    if f.is_key:
      keys.append(code)
    else:
      members.append(code)

  return {
    'members_key': '\n  '.join(keys),
    'members_field': '\n  '.join(members)
  }

def generateJavaModel(entityNs, entityName, imports, inlineEnums, fields):
  templateFields = {
    'build_date': str(datetime.now()),
    'entity_ns': entityNs,
    'entity_name': entityName,
    'custom_import': '\n'.join('import %s;' % name for name in imports),
    'inline_enums': '\n'.join('enum %s { %s }' % (enum.name, ', '.join(enum.values)) for enum in inlineEnums),
    'fields_count': len(fields),
    'ctor_copy': _generateJavaCtorCopy(fields),
    'getter_setter': _generateJavaSettersAndGetters(entityName, fields),
    'entity_string': _generateJavaModelToString(entityName, fields)
  }
  templateFields.update(_generateJavaModelMembers(fields))
  return replaceTemplateVars(JAVA_MODEL_TEMPLATE, templateFields)

def generateJavaEnum(entityNs, entityName, enumValues):
  templateFields = {
    'build_date': str(datetime.now()),
    'entity_ns': entityNs,
    'entity_name': entityName,
    'enum_values': ',\n  '.join(enumValues)
  }
  return replaceTemplateVars(JAVA_ENUM_TEMPLATE, templateFields)

def removeComments(text):
  text = re.sub(re.compile("/\*.*?\*/", re.DOTALL ), '',text) # remove all occurrences streamed comments (/*COMMENT */) from string
  text = re.sub(re.compile("//.*?\n" ), '', text) # remove all occurrence single-line comments (//COMMENT\n ) from string
  return text

if __name__ == '__main__':
  if len(sys.argv) < 3:
    print('StorageModelGenerator <code dir> <model>')
    sys.exit(1)

  ENTITY_REGEX = r'(\S+)\s*[^{]*{\s*([^}]+)\s*}'
  FIELD_REGEX  = r'\s*(@\S*)*\s*(\S+)\s+(\S+)\s*=?\s*(\S*);'
  INLINE_ENUM_REGEX = r'enum\s+(\S+)\s*\[(.*?)\]\s*;'
  IMPORT_REGEX = r'\s*import\s+(\S+)\s*;'
  COALESCE_WHITESPACE = re.compile(r"\s+")

  for modelFile in sys.argv[2:]:
    with open(modelFile, 'r') as fd:
      entitiesConfig = fd.read()

    #print('reading %s' % modelFile)
    entitiesConfig = removeComments(entitiesConfig)
    for entityFullName, entityFields in re.findall(ENTITY_REGEX, entitiesConfig):
      # extract entity name and namespace
      nsIndex = entityFullName.rindex('.')
      entityNs = entityFullName[:nsIndex]
      entityName = entityFullName[nsIndex + 1:]

      # extract entity imports
      imports = re.findall(IMPORT_REGEX, entityFields)

      # extract inline enums
      inlineEnums = [InlineEnum(*fields) for fields in re.findall(INLINE_ENUM_REGEX, entityFields)]

      # cleanup entity fields
      entityFields = re.sub(IMPORT_REGEX, '', entityFields)
      entityFields = re.sub(INLINE_ENUM_REGEX, '', entityFields)
      entityFields = COALESCE_WHITESPACE.sub(' ', entityFields)

      # BODGE: entity or enum parsing
      fields = [EntityField(*field) for field in re.findall(FIELD_REGEX, entityFields)]
      if fields:
        print('Entity', entityName, fields)
        javaCode = generateJavaModel(entityNs, entityName, imports, inlineEnums, fields)
      else:
        enumFields = [enumField.strip() for enumField in entityFields.split(',')]
        print('Enum', entityName, enumFields)
        javaCode = generateJavaEnum(entityNs, entityName, enumFields)

      javaCodePath = '%s.java' % os.path.join(sys.argv[1], entityNs.replace('.', '/'), entityName)
      with open(javaCodePath, 'w') as fd: fd.write(javaCode)
      print(' - generate into %s' % javaCodePath)
